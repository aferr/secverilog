/*
	REDEMO.C - Demo Application using RSAEURO cryptographic toolkit

	Copyright (c) J.S.A.Kapp 1994.

	RSAEURO - RSA Library compatible with RSAREF(tm) 2.0.

	All functions prototypes are the Same as for RSAREF(tm).
	To aid compatiblity the source and the files follow the
	same naming comventions that RSAREF(tm) uses.  This should aid
	direct importing to your applications.

	This library is legal everywhere outside the US.  And should
	NOT be imported to the US and used there.

	This application shows how to use RSAEURO routines in your
	applications.
*/


#include <stdio.h>
#include <string.h>
#include "rsaeuro.h"		/* Required Prototypes */
#include "mitigateutil.h"

/* Implement these simple routines as macros */

#define ReadClose(file) \
{               \
	fclose (file);\
}


#define WriteClose(file) \
{                   \
	if(file != stdout)\
		fclose(file);   \
}

#define PrintMessage(message) \
{                 \
	puts(message);  \
	fflush(stdout); \
}

/* Internal function prototypes */

static R_RANDOM_STRUCT *InitRandomStruct PROTO_LIST((void));
static void DoSealFile PROTO_LIST((R_RANDOM_STRUCT *, char *, char *));
static void DoOpenFile PROTO_LIST((char *, char *));
static int ReadInit PROTO_LIST((FILE **, char *));
static int ReadUpdate PROTO_LIST
	((FILE *, unsigned char *, unsigned int *, unsigned int));
static int WriteInit PROTO_LIST((FILE **, char *));
static int WriteUpdate PROTO_LIST((FILE *, unsigned char *, unsigned int));
static int GetPublicKey PROTO_LIST((R_RSA_PUBLIC_KEY **));
static int GetPrivateKey PROTO_LIST((R_RSA_PRIVATE_KEY **));
static void PrintMessage PROTO_LIST((char *));
static void PrintError PROTO_LIST((char *, int));

/* Use one key from RSADSI's RSAREF(tm) RDEMO for comptiblity testing.
	 This ensures that both RSAEURO and RSAREF(tm) code is compatible.
*/

static R_RSA_PUBLIC_KEY PUBLIC_KEY1 = {
	512,
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	 0x00, 0x00, 0x00, 0x00, 0xc0, 0x76, 0x47, 0x97, 0xb8, 0xbe, 0xc8, 0x97,
	 0x2a, 0x0e, 0xd8, 0xc9, 0x0a, 0x8c, 0x33, 0x4d, 0xd0, 0x49, 0xad, 0xd0,
	 0x22, 0x2c, 0x09, 0xd2, 0x0b, 0xe0, 0xa7, 0x9e, 0x33, 0x89, 0x10, 0xbc,
	 0xae, 0x42, 0x20, 0x60, 0x90, 0x6a, 0xe0, 0x22, 0x1d, 0xe3, 0xf3, 0xfc,
	 0x74, 0x7c, 0xcf, 0x98, 0xae, 0xcc, 0x85, 0xd6, 0xed, 0xc5, 0x2d, 0x93,
	 0xd5, 0xb7, 0x39, 0x67, 0x76, 0x16, 0x05, 0x25},
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01}
};

static R_RSA_PRIVATE_KEY PRIVATE_KEY1 = {
	512,
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	 0x00, 0x00, 0x00, 0x00, 0xc0, 0x76, 0x47, 0x97, 0xb8, 0xbe, 0xc8, 0x97,
	 0x2a, 0x0e, 0xd8, 0xc9, 0x0a, 0x8c, 0x33, 0x4d, 0xd0, 0x49, 0xad, 0xd0,
	 0x22, 0x2c, 0x09, 0xd2, 0x0b, 0xe0, 0xa7, 0x9e, 0x33, 0x89, 0x10, 0xbc,
   0xae, 0x42, 0x20, 0x60, 0x90, 0x6a, 0xe0, 0x22, 0x1d, 0xe3, 0xf3, 0xfc,
	 0x74, 0x7c, 0xcf, 0x98, 0xae, 0xcc, 0x85, 0xd6, 0xed, 0xc5, 0x2d, 0x93,
   0xd5, 0xb7, 0x39, 0x67, 0x76, 0x16, 0x05, 0x25},
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01},
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	 0x00, 0x00, 0x00, 0x00, 0x1a, 0xe3, 0x6b, 0x75, 0x22, 0xf6, 0x64, 0x87,
	 0xd9, 0xf4, 0x61, 0x0d, 0x15, 0x50, 0x29, 0x0a, 0xc2, 0x02, 0xc9, 0x29,
   0xbe, 0xdc, 0x70, 0x32, 0xcc, 0x3e, 0x02, 0xac, 0xf3, 0x7e, 0x3e, 0xbc,
	 0x1f, 0x86, 0x6e, 0xe7, 0xef, 0x7a, 0x08, 0x68, 0xd2, 0x3a, 0xe2, 0xb1,
   0x84, 0xc1, 0xab, 0xd6, 0xd4, 0xdb, 0x8e, 0xa9, 0xbe, 0xc0, 0x46, 0xbd,
	 0x82, 0x80, 0x37, 0x27, 0xf2, 0x88, 0x87, 0x01},
	{{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xdf, 0x02, 0xb6, 0x15,
		0xfe, 0x15, 0x92, 0x8f, 0x41, 0xb0, 0x2b, 0x58, 0x6b, 0x51, 0xc2, 0xc0,
		0x22, 0x60, 0xca, 0x39, 0x68, 0x18, 0xca, 0x4c, 0xba, 0x60, 0xbb, 0x89,
		0x24, 0x65, 0xbe, 0x35},
	 {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xdc, 0xee, 0xb6, 0x0d,
		0x54, 0x35, 0x18, 0xb4, 0xac, 0x74, 0x83, 0x4a, 0x05, 0x46, 0xc5, 0x07,
		0xf2, 0xe9, 0x1e, 0x38, 0x9a, 0x87, 0xe2, 0xf2, 0xbe, 0xcc, 0x6f, 0x8c,
		0x67, 0xd1, 0xc9, 0x31}},
	{{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x59, 0x48, 0x7e, 0x99,
		0xe3, 0x75, 0xc3, 0x8d, 0x73, 0x21, 0x12, 0xd9, 0x7d, 0x6d, 0xe8, 0x68,
		0x7f, 0xda, 0xfc, 0x5b, 0x6b, 0x5f, 0xb1, 0x6e, 0x72, 0x97, 0xd3, 0xbd,
		0x1e, 0x43, 0x55, 0x99},
	 {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x61, 0xb5, 0x50, 0xde,
		0x64, 0x37, 0x77, 0x4d, 0xb0, 0x57, 0x77, 0x18, 0xed, 0x6c, 0x77, 0x07,
		0x24, 0xee, 0xe4, 0x66, 0xb4, 0x31, 0x14, 0xb5, 0xb6, 0x9c, 0x43, 0x59,
		0x1d, 0x31, 0x32, 0x81}},
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x74, 0x4c, 0x79, 0xc4,
	 0xb9, 0xbe, 0xa9, 0x7c, 0x25, 0xe5, 0x63, 0xc9, 0x40, 0x7a, 0x2d, 0x09,
	 0xb5, 0x73, 0x58, 0xaf, 0xe0, 0x9a, 0xf6, 0x7d, 0x71, 0xf8, 0x19, 0x8c,
	 0xb7, 0xc9, 0x56, 0xb8}
};

#define DECRYPT

int main(int argc, char *argv[])
{
        int i=1;
	R_RANDOM_STRUCT *randomStruct;
        randomStruct = InitRandomStruct();		/* setup random object */

#ifdef DECRYPT
        DoOpenFile(argv[1], argv[2]);
#else
        DoSealFile(randomStruct, argv[1], argv[2]);
#endif
}

/*
	Initialize the random structure with all NULL seed bytes for
	test purposes.  This will NOT produce a random stream, for a
	random stream one needs a random seed.

	See: R_RandomCreate
*/

static R_RANDOM_STRUCT *InitRandomStruct(void)
{
	static unsigned char seedByte = 0;
	unsigned int bytesNeeded;
	static R_RANDOM_STRUCT randomStruct;

	R_RandomInit(&randomStruct);

	/* Initialize with all zero seed bytes, which will not yield an actual
			 random number output. */

	while (1) {
		R_GetRandomBytesNeeded(&bytesNeeded, &randomStruct);
		if(bytesNeeded == 0)
			break;

		R_RandomUpdate(&randomStruct, &seedByte, 1);
	}

	return(&randomStruct);
}

static void DoSealFile(randomStruct, in, out)
R_RANDOM_STRUCT *randomStruct;
char *in;
char *out;
{
	FILE *inFile, *outFile;
	R_ENVELOPE_CTX context;
	R_RSA_PUBLIC_KEY *publicKey;
	int encryptionAlgorithm, status;
	unsigned char encryptedKey[MAX_ENCRYPTED_KEY_LEN],
		partIn[48], partOut[64];
	unsigned int encryptedKeyLen, partInLen, partOutLen;

	status = 0;

	if(ReadInit(&inFile, in))
		return;

	if(WriteInit(&outFile, out)) {
		ReadClose(inFile);
		return;
	}

	if(GetPublicKey(&publicKey)) {
                while (!ReadUpdate (inFile, partIn, &partInLen, sizeof (partIn))) {
			if ((status = RSAPublicEncrypt(partOut, &partOutLen, partIn, partInLen, publicKey, randomStruct))!= 0)
	                        break;
			WriteUpdate (outFile, partOut, partOutLen);
                }
	}

	ReadClose(inFile);
	WriteClose(outFile);

	if(status)
		PrintError ("sealing file", status);

	R_memset((POINTER)&context, 0, sizeof(context));
	R_memset((POINTER)partIn, 0, sizeof(partIn));
}

static void DoOpenFile(in, out)
char *in;
char *out;
{
	FILE *inFile, *outFile;
	R_ENVELOPE_CTX context;
	R_RSA_PRIVATE_KEY *privateKey;
	int status, blocks=0;
        long start, end;
	unsigned char encryptedKey[MAX_ENCRYPTED_KEY_LEN], partIn[64],
		partOut[48];
	unsigned int encryptedKeyLen, ivLen, partInLen, partOutLen;

	status = 0;

	if (ReadInit(&inFile, in))
		return;

	if (WriteInit(&outFile, out)) {
		ReadClose(inFile);
		return;
	}

        READ_CLOCK(start)

	if(GetPrivateKey(&privateKey))
		while (!ReadUpdate(inFile, partIn, &partInLen, sizeof (partIn))) {
			if((status = RSAPrivateDecrypt(partOut, &partOutLen, partIn, partInLen, privateKey)) != 0)
				break;
			WriteUpdate(outFile, partOut, partOutLen);
                        blocks++;
		}
        ReadClose(inFile);
	WriteClose(outFile);

        READ_CLOCK(end)
        printf("decryption time: %d\n", end-start);

	if(status)
		PrintError("Opening File", status);

        printf("decrypted %d blocks\n", blocks);
	R_memset((POINTER)&context, 0, sizeof(context));
	R_memset((POINTER)partOut, 0, sizeof(partOut));
}

/* use public key 1 */
static int GetPublicKey (publicKey)
R_RSA_PUBLIC_KEY **publicKey;
{
	*publicKey = &PUBLIC_KEY1;
	return (1);
}

/* use private key 1 */
static int GetPrivateKey(privateKey)
R_RSA_PRIVATE_KEY **privateKey;
{
	*privateKey = &PRIVATE_KEY1;
	return (1);
}

/* Ask for the filename using the given prompt string and open it
		 for reading.
	 Return 0 on success or 1 if error or if user cancels by entering a blank.
 */
static int ReadInit (file, prompt)
FILE **file;
char *prompt;
{
    
        if ((*file = fopen (prompt, "r")) == NULL)
		PrintError ("ERROR: Cannot open a file with that name.  Try again.", 0);
          return (0);
}

/* Read a block of up to length maxPartOutLen bytes from file, storing
		 it in partOut and returning its length in partOutLen.
   Return 0 on success or 1 if error or end of file.
 */
static int ReadUpdate (file, partOut, partOutLen, maxPartOutLen)
FILE *file;
unsigned char *partOut;
unsigned int *partOutLen;
unsigned int maxPartOutLen;
{
  int status;
  
	/* fread () returns the number of items read in.
	 */
	*partOutLen = fread (partOut, 1, maxPartOutLen, file);

  status = 0;
  if (ferror (file)) {
		PrintError ("ERROR: Cannot read file.", 0);
    status = 1;
  }
  if (*partOutLen == 0 && feof (file))
		status = 1;

	return (status);
}

/* Ask for the filename using the given prompt string and open it
	 for writing.
	 Return 0 on success or 1 if error or if user cancels by entering a blank.
*/

static int WriteInit (file, prompt)
FILE **file;
char *prompt;
{
	if((*file = fopen (prompt, "w")) == NULL)
        	PrintError("ERROR: Cannot open a file with that name.  Try again.", 0);
	return(0);
}

/* Write block of length partOutLen to a file.
	 Return 0 on success or 1 if error.
 */
static int WriteUpdate(file, partOut, partOutLen)
FILE *file;
unsigned char *partOut;
unsigned int partOutLen;
{
	int status;

	status = 0;
	if(fwrite(partOut, 1, partOutLen, file) < partOutLen) {
		PrintError("ERROR: Cannot write file.", 0);
		status = 1;
	}

	return(status);
}

/* If type is zero, simply print the task string, otherwise convert the
		 type to a string and print task and type.
 */
static void PrintError(task, type)
char *task;
int type;
{
	char *typeString, *msg[] = {
						"Recovered DES key cannot decrypt encrypted content",
						"Encrypted key length or signature length is out of range",
						"Modulus length is out of range",
						"Private key cannot encrypt message digest, or cannot decrypt encrypted key",
						"Public key cannot encrypt data encryption key, or cannot decrypt signature",
						"Signature is incorrect",
						"Unknown Error",
						NULL };

	if(type == 0) {		/* Non RSAEURO Related Error */
		puts(task);			/* Internal Deal with it */
		return;
	}

	/* Convert the type to a string if it is recognized.	 */
	switch(type) {
	case RE_KEY:
		typeString = msg[0];
		break;
	case RE_LEN:
		typeString = msg[1];
		break;
	case RE_MODULUS_LEN:
		typeString = msg[2];
		break;
	case RE_PRIVATE_KEY:
		typeString = msg[3];
		break;
	case RE_PUBLIC_KEY:
		typeString = msg[4];
		break;
	case RE_SIGNATURE:
		typeString = msg[5];
		break;

	default:
		printf("ERROR: Code 0x%04x, %s", type, msg[6]);
		fflush(stdout);
		return;
	}

	printf("ERROR: %s while %s\n", typeString, task);
	fflush(stdout);
}
